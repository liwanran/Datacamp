{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 1. Container sequences: python provides several container sequences such as lists, sets, and tuples.\n",
    "Lists and sets are mutable. Tuples are immutable.They are iterable, which allow us to group data, aggregate it and process it over time."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "list"
      ]
     },
     "execution_count": 42,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ice_cream = ['vanilla', 'rum&raisin', 'chocolate']\n",
    "type(ice_cream)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1) 3 methods to combine lists: .append(), +, .extend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['vanilla', 'rum&raisin', 'chocolate', 'strawberry']"
      ]
     },
     "execution_count": 43,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#1 .append()\n",
    "ice_cream.append('strawberry')\n",
    "ice_cream"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['vanilla', 'rum&raisin', 'chocolate', 'strawberry', 'black forest', 'durian']"
      ]
     },
     "execution_count": 44,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#2 using +\n",
    "cakes = ['black forest', 'durian']\n",
    "ice_cream + cakes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['vanilla', 'rum&raisin', 'chocolate', 'strawberry', 'black forest', 'durian']\n"
     ]
    }
   ],
   "source": [
    "#3 using list.extend(list1), then print(list)\n",
    "ice_cream.extend(cakes)\n",
    "print(ice_cream)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2) Lists allow us to access an individual element within them using an index: list.index(), list[0]\n",
    "<p>.index(): to locate the position of a data element in a list.</p>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n"
     ]
    }
   ],
   "source": [
    "#1 using .index()\n",
    "a = ice_cream.index('rum&raisin')\n",
    "print(a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'vanilla'"
      ]
     },
     "execution_count": 47,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# using list[0]\n",
    "ice_cream[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3) to remove an item from a list: .pop()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "rum&raisin\n"
     ]
    }
   ],
   "source": [
    "b = ice_cream.pop(1)\n",
    "print(b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['vanilla', 'chocolate', 'strawberry', 'black forest', 'durian']"
      ]
     },
     "execution_count": 49,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ice_cream"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "4) to iterate over a list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "vanilla\n",
      "chocolate\n",
      "strawberry\n",
      "black forest\n",
      "durian\n"
     ]
    }
   ],
   "source": [
    "for flavor in ice_cream:\n",
    "    print(flavor)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "5) sorted(): sort by alphabetical order"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['black forest', 'chocolate', 'durian', 'strawberry', 'vanilla']"
      ]
     },
     "execution_count": 52,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sorted(ice_cream)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Practice"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['Albert', 'Calvin', 'Jiayu', 'Eliza', 'Zoey']\n"
     ]
    }
   ],
   "source": [
    "# using .extend()\n",
    "baby_names = ['Albert', 'Calvin', 'Jiayu']\n",
    "baby_names.extend(['Eliza', 'Zoey'])\n",
    "print(baby_names)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'Jiayu'"
      ]
     },
     "execution_count": 82,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# to remove a name\n",
    "x = baby_names.index('Jiayu')\n",
    "baby_names.pop(x)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 91,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['Albert', 'Calvin', 'Eliza', 'Zoey']\n"
     ]
    }
   ],
   "source": [
    "print(baby_names)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Albert\n",
      "Calvin\n",
      "Eliza\n",
      "Zoey\n"
     ]
    }
   ],
   "source": [
    "# using sorted()\n",
    "for name in sorted(baby_names):\n",
    "    print(name)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "metadata": {},
   "outputs": [],
   "source": [
    "# using loop & sorted\n",
    "records = ['2011', 'FEMALE', 'HISPANIC', 'GERALDINE', '13', '75']\n",
    "girl_names = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['GERALDINE', 'GERALDINE', 'GERALDINE', 'GERALDINE', 'GERALDINE', 'GERALDINE']\n"
     ]
    }
   ],
   "source": [
    "for record in records:\n",
    "    girl_names.append(records[3])\n",
    "print(girl_names)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for baby_names"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 2. Tuples: tuples are easier to process and more memory efficient than lists. They are immutable, therefore we can use them to ensure that our data is not altered.\n",
    "# We can create tuples by pairing up elements.\n",
    "# We can use unpacking to expand a tuple into named variables that represent each element in the tuple."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1) Zipping & unpacking: we can have lists where we want to matchup elements into pairs: zip(), enumerate() or ()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 135,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<zip at 0x108929088>"
      ]
     },
     "execution_count": 135,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "chinese = ['lotus', 'pandas', 'wechat']\n",
    "us = ['rose', 'eagle', 'whatsapp']\n",
    "pairs = zip(chinese, us)\n",
    "pairs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 136,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<zip object at 0x108929088>\n"
     ]
    }
   ],
   "source": [
    "print(pairs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 137,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "('lotus', 'rose')\n",
      "('pandas', 'eagle')\n",
      "('wechat', 'whatsapp')\n"
     ]
    }
   ],
   "source": [
    "#1 to create a tuple by using zip()\n",
    "for pair in pairs:\n",
    "    print(pair)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 140,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "lotus\n",
      "rose\n",
      "pandas\n",
      "eagle\n",
      "wechat\n",
      "whatsapp\n"
     ]
    }
   ],
   "source": [
    "pairs = zip(chinese, us)\n",
    "for c, u in pairs:\n",
    "    print(c)\n",
    "    print(u)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 151,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 lotus rose\n",
      "Type 0: lotus and rose\n",
      "1 pandas eagle\n",
      "Type 1: pandas and eagle\n",
      "2 wechat whatsapp\n",
      "Type 2: wechat and whatsapp\n"
     ]
    }
   ],
   "source": [
    "#2 using enumerate to create a tuple. We can't use pair = c, u.\n",
    "pairs = zip(chinese, us)\n",
    "for idx, pair in enumerate(pairs):\n",
    "    c, u = pair\n",
    "    print(idx, c, u)\n",
    "    print('Type {}: {} and {}'.format(idx, c, u))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 154,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "('wine', 'rum', 'baileys')\n"
     ]
    }
   ],
   "source": [
    "#3 using ()\n",
    "alcohol = ('wine', 'rum', 'baileys')\n",
    "print(alcohol)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 157,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "('juice',)\n",
      "<class 'str'>\n",
      "<class 'tuple'>\n"
     ]
    }
   ],
   "source": [
    "#4 beware of tailing commas\n",
    "alcohol1 = 'juice'\n",
    "alcohol2 = 'juice',\n",
    "print(alcohol2)\n",
    "print(type(alcohol1))\n",
    "print(type(alcohol2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 3. Sets: good for finding unique values in a column of your data, a list of elements, or rows from a file. They are mutable.\n",
    "# We use sets when we want to store unique data elements in an unordered fashion.\n",
    "# Sets are created from a list."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 160,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'chocolate', 'rum&raisin', 'vanilla'}"
      ]
     },
     "execution_count": 160,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ice_cream = set(['vanilla', 'rum&raisin', 'vanilla', 'chocolate'])\n",
    "ice_cream"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 161,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "set"
      ]
     },
     "execution_count": 161,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "type(ice_cream)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1) Modifying sets: \n",
    "<p>.add(): add a single element</p>\n",
    ".update(): merges in another list or set\n",
    "<br>.discard(): remove a single element by value</br>\n",
    "<br>.pop(): remove an arbitrary element from the set</br>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 163,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'chocolate', 'rum&raisin', 'strawberry', 'vanilla'}"
      ]
     },
     "execution_count": 163,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#1 using .add()\n",
    "ice_cream.add('strawberry')\n",
    "ice_cream"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 165,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'black forest', 'chocolate', 'puff', 'rum&raisin', 'strawberry', 'vanilla'}"
      ]
     },
     "execution_count": 165,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#2 using .update()\n",
    "cakes = ['black forest', 'puff']\n",
    "ice_cream.update(cakes)\n",
    "ice_cream"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 166,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "set"
      ]
     },
     "execution_count": 166,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "type(ice_cream)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 167,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'black forest', 'chocolate', 'rum&raisin', 'strawberry', 'vanilla'}"
      ]
     },
     "execution_count": 167,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#3 .discard() by using a value\n",
    "ice_cream.discard('puff')\n",
    "ice_cream"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 168,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'black forest', 'chocolate', 'rum&raisin', 'strawberry'}"
      ]
     },
     "execution_count": 168,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#4 .pop()\n",
    "ice_cream.pop()\n",
    "ice_cream"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2) find similarities in 2 sets\n",
    "<p>.union(): returns a set of all names.</p>\n",
    ".intersection(): identifying overlapping data.\n",
    "<br>.difference(): identifies data present in the set. The target is important as that will be the basis for our diff.</br>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 176,
   "metadata": {},
   "outputs": [],
   "source": [
    "ice_cream = set(['vanilla', 'rum&raisin', 'vanilla', 'chocolate', 'coffee'])\n",
    "alcohol = set(['wine', 'coffee', 'rum'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 177,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'chocolate', 'coffee', 'rum', 'rum&raisin', 'vanilla', 'wine'}"
      ]
     },
     "execution_count": 177,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#1 .union()\n",
    "x = ice_cream.union(alcohol)\n",
    "x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 178,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'coffee'}"
      ]
     },
     "execution_count": 178,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#2 .intersection()\n",
    "y = ice_cream.intersection(alcohol)\n",
    "y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 179,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'chocolate', 'rum&raisin', 'vanilla'}"
      ]
     },
     "execution_count": 179,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#3 .difference()\n",
    "ice_cream.difference(alcohol)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 180,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'rum', 'wine'}"
      ]
     },
     "execution_count": 180,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "alcohol.difference(ice_cream)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 4. Dictionary: useful for storing key/value pair, grouping data by time, or structuring hierarchical data like org charts.\n",
    "# Key must be alphanumeric. The value can be any other data type.\n",
    "# We can create dictionaries using the dict( ) method or { }.\n",
    "\n",
    ".get(): locate a value by using a key.\n",
    "<br>.keys(): list all keys in a dictionary.</br>\n",
    "<br>.items(): return an object that we can iterate over.</br>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 196,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create by {}\n",
    "liquors = {'baileys':'dark', 'rum':'transparent', 'rose':'pink'}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 197,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'pink'"
      ]
     },
     "execution_count": 197,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#1 using a key to find a value\n",
    "liquors['rose']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 200,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'pink'"
      ]
     },
     "execution_count": 200,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#2 .get()\n",
    "liquors.get('rose', 'not found')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 201,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'not found'"
      ]
     },
     "execution_count": 201,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "liquors.get('ice_wine', 'not found')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 202,
   "metadata": {},
   "outputs": [],
   "source": [
    "liquors.get('ice_wine')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 203,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dict_keys(['baileys', 'rum', 'rose'])"
      ]
     },
     "execution_count": 203,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#3 .keys()\n",
    "liquors.keys()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 210,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "baileys\n",
      "dark\n",
      "rum\n",
      "transparent\n",
      "rose\n",
      "pink\n"
     ]
    }
   ],
   "source": [
    "#4 .items()\n",
    "for name, color in liquors.items():\n",
    "    print(name)\n",
    "    print(color)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 214,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 214,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# checking keys in dictionary\n",
    "'rum' in liquors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 215,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 215,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "'pink' in liquors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 216,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Found it\n"
     ]
    }
   ],
   "source": [
    "if 'rum' in liquors:\n",
    "    print('Found it')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 220,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Not found\n"
     ]
    }
   ],
   "source": [
    "if 'pink' in liquors:\n",
    "    print('Found it')\n",
    "else:\n",
    "    print('Not found')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
